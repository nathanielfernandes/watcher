use std::{convert::Infallible, env, io::Write};

use activity::{DiscordActivity, NoCopy};
use async_stream::stream;
use axum::{
    async_trait,
    extract::{Path, State},
    http::StatusCode,
    response::{
        sse::{Event, KeepAlive},
        IntoResponse, Response, Sse,
    },
    routing::get,
};
use events::Dispatcher;
use futures::Stream;
use imstr::ImString;
use once_cell::sync::Lazy;
use serenity::{
    model::prelude::{Presence, Ready},
    prelude::{Context, EventHandler, GatewayIntents},
    Client,
};
use tokio::sync::mpsc::UnboundedReceiver;
use tower_http::cors::CorsLayer;

pub mod activity;
pub mod events;

static ALLOW_LIST: Lazy<Vec<u64>> = Lazy::new(|| {
    env::var("ALLOW_LIST")
        .expect("Expected a list of user IDs in the environment")
        .split(',')
        .map(|id| {
            id.parse::<u64>()
                .expect("Expected a list of user IDs in the environment")
        })
        .collect()
});

static SERVER: Lazy<u64> = Lazy::new(|| {
    env::var("SERVER")
        .expect("Expected a server ID in the environment")
        .parse::<u64>()
        .expect("Expected a server ID in the environment")
});

#[derive(Clone)]
struct AppState {
    dispatcher: Dispatcher<u64, ImString>,
}

#[tokio::main]
async fn main() {
    println!("generating ts exports");

    // output definition files ONLY during development mode
    #[cfg(debug_assertions)]
    {
        let mut buffer =
            String::from("/** this file is automatically generated, do not edit **/\n\n");
        buffer += &specta::ts::export::<DiscordActivity>(&Default::default())
            .expect("failed to generate ts exports");
        buffer += ";\n";

        let path = std::path::Path::new("./ts/activity.ts");

        // remove the file if it exists
        if path.exists() {
            std::fs::remove_file(path).expect("failed to remove file");
        }

        // write the file
        let mut file = std::fs::File::create(path).expect("failed to create file");
        file.write_all(buffer.as_bytes())
            .expect("failed to write file");
    }
    println!("Starting up...");

    let state = AppState {
        dispatcher: Dispatcher::new(),
    };

    let s = state.clone();
    tokio::spawn(async move {
        let token = env::var("TOKEN").expect("Expected a token in the environment");

        let intents = GatewayIntents::GUILD_PRESENCES | GatewayIntents::GUILD_MEMBERS;

        let mut client = Client::builder(token, intents)
            .event_handler(s)
            .await
            .expect("Error creating client");

        if let Err(why) = client.start().await {
            println!("Client error: {:?}", why);
        }
    });

    let cors = CorsLayer::very_permissive();

    let app = axum::Router::new()
        .route("/", get(root))
        .route("/activity/:user_id", get(get_activity))
        .route("/live-activity/:user_id", get(live_activity))
        .layer(cors)
        .with_state(state);

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], 2223));

    println!("Listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn root() -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    Sse::new(stream! {
        loop {
            tokio::time::sleep(std::time::Duration::from_secs(1)).await;
            yield Ok(Event::default().data("Hello, world!"));
        }
    })
    .keep_alive(KeepAlive::new().interval(std::time::Duration::from_secs(10)))
}

const JSON_HEADERS: [(&str, &str); 2] = [
    ("Content-Type", "application/json"),
    ("Cache-Control", "no-cache"),
];

async fn get_activity(State(state): State<AppState>, Path(user_id): Path<u64>) -> Response {
    match state.dispatcher.last_event(user_id).await {
        Some(data) => {
            let data = data.into_bytes();
            (JSON_HEADERS, data).into_response()
        }
        None => (
            JSON_HEADERS,
            serde_json::to_string::<[String; 0]>(&[]).unwrap_or_default(),
        )
            .into_response(),
    }
}

fn create_stream(
    mut rx: UnboundedReceiver<ImString>,
    last_event: Option<ImString>,
) -> impl Stream<Item = Result<Event, Infallible>> {
    stream! {
        if let Some(data) = last_event {
            yield Ok(Event::default().data(data));
        }

        loop {
            match rx.recv().await {
                Some(data) => {
                    yield Ok(Event::default().data(data));
                }
                None => {
                    break;
                }
            }
        };
    }
}

async fn live_activity(State(state): State<AppState>, Path(user_id): Path<u64>) -> Response {
    if !ALLOW_LIST.contains(&user_id) {
        return (StatusCode::NOT_FOUND, "Forbidden").into_response();
    }

    let (rx, last_event) = state.dispatcher.subscribe(user_id).await;

    let stream = create_stream(rx, last_event);

    let sse =
        Sse::new(stream).keep_alive(KeepAlive::new().interval(std::time::Duration::from_secs(10)));

    return sse.into_response();
}

#[async_trait]
impl EventHandler for AppState {
    // As the intents set in this example, this event shall never be dispatched.
    // Try it by changing your status.
    async fn presence_update(&self, _ctx: Context, presence: Presence) {
        if presence.guild_id.unwrap_or_default().0 != *SERVER {
            return;
        }

        let user_id = presence.user.id.0;

        if !ALLOW_LIST.contains(&user_id) {
            return;
        }

        let activites = presence
            .activities
            .into_iter()
            .map(|a| a.into())
            .collect::<Vec<DiscordActivity>>();

        let data = activites.imstr();

        self.dispatcher.publish(user_id, data).await;
    }

    async fn ready(&self, _: Context, ready: Ready) {
        println!("{} is connected!", ready.user.name);
    }
}
